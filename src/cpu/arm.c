#include <stdbool.h>
#include <stdint.h>
#include "arm7tdmi.h"
#include "cgba/cpu.h"

#define COND_N_BITMASK (1 << 31)
#define COND_Z_BITMASK (1 << 30)
#define COND_C_BITMASK (1 << 29)
#define COND_V_BITMASK (1 << 28)

// decode ARM condition field
static bool check_cond(arm7tdmi *cpu)
{
    bool n_set = cpu->cpsr & COND_N_BITMASK;
    bool z_set = cpu->cpsr & COND_Z_BITMASK;
    bool c_set = cpu->cpsr & COND_C_BITMASK;
    bool v_set = cpu->cpsr & COND_V_BITMASK;

    bool result;
    switch ((cpu->pipeline[0] >> 28) & 0xf)
    {
        case 0x0: result = z_set; break;
        case 0x1: result = !z_set; break;

        case 0x2: result = c_set; break;
        case 0x3: result = !c_set; break;

        case 0x4: result = n_set; break;
        case 0x5: result = !n_set; break;

        case 0x6: result = v_set; break;
        case 0x7: result = !v_set; break;

        case 0x8: result = c_set && !z_set; break;
        case 0x9: result = !c_set || z_set; break;

        case 0xa: result = n_set == v_set; break;
        case 0xb: result = n_set != v_set; break;

        case 0xc: result = !z_set && (n_set == v_set); break;
        case 0xd: result = z_set || (n_set != v_set); break;

        case 0xe: result = true; break;

        // 0b1111 is reserved and should not be used
        case 0xf: result = false; break;
    }

    return result;
}

void bx(arm7tdmi *cpu)
{
    if (!check_cond(cpu))
        return;

    arm_register rn = cpu->pipeline[0] & 0xf;
    uint32_t addr = cpu->registers[rn];

    if (addr & 1) // THUMB state
    {
        // halfword-align the instruction
        addr &= ~1;
        cpu->cpsr |= T_BITMASK;
    }
    else // ARM state
    {
        cpu->cpsr &= ~T_BITMASK;
    }

    cpu->registers[R15] = addr;

    // BX causes a pipeline flush and refill from [Rn]
    reload_pipeline(cpu);
}
